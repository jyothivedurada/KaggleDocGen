0	Load the DICOM image and convert to pixel array
1	store the raw image data
2	Add new Features
3	Reset Index for Fast Update
4	Remove Unused Columns
5	Encode Categorical Data
6	eliminate bad rows
7	declare target , categorical and numeric columns
8	merge with building info
9	fill test weather data
10	merge weather data
11	Compute the STA and the LTA
12	This block is SPPED UP
13	Loading Train and Test Data
14	Seems like a very wide range of values , relatively spaking
15	Common data processors
16	To plot pretty figures
17	Now extract the data from the new transactions
18	impute missing values
19	Imputations and Data Transformation
20	Check for missing values in training set
21	Check for missing values in training set
22	Impute any values will significantly affect the RMSE score for test set
23	Detect and Correct Outliers
24	Remove the Outliers if any
25	Loading Train and Test Data
26	No surprises , since this is all presumably artificial data
27	Now there appears to be one feature that is not gaussian
28	MODEL WITH SUPPORT VECTOR MACHINE
29	Loading Train and Test Data
30	Read data set
31	Text preprosesing source
32	Model Validation on train data set
33	prophet expects the folllwing label names
34	Loading Train and Test Data
35	And now we embed each chunk individually
36	And it looks like a fairly nice distribution , albeit still fairly asymetrical
37	Maybe if we used the log plot things would be better
38	Look at the data types and some basic info about the different columns
39	Sample usage to extract batch for training
40	Getting to Know the Data
41	The Shape of the Data
42	Group date and time counts by years , months and days
43	Determine left , right and bottom coordinates of each bar in the plot
44	Create colors for bars based on bar height
45	Draw one bar for each date
46	Group date and time counts by months
47	Determine left , right and bottom coordinates of each bar in the plot
48	Create colors for bars based on bar height
49	Draw one bar for each month
50	Group date and time counts by hours
51	Determine left , right and bottom coordinates of each bar in the plot
52	Create colors for bars based on bar height
53	Draw one bar for each hour
54	Print some statistics
55	There is one cluster for noisy examples , labeled as
56	Importing all Libraries
57	Seed everything for reproducibility
58	Defining DataBunch for FastAI
59	Unfreeze all layers and find best learning rate
60	Predicting for test data
61	functions to get new parameters from the column
62	distribution of categorical variables
63	distribution of continuse variables
64	distribution of continuse variables after log transformation
65	save pneumonia location in dictionary
66	load and shuffle filenames
67	split into train and validation filenames
68	if augment then horizontal flip half the time
69	add trailing channel dimension
70	add trailing channel dimension
71	create numpy batch
72	define iou or jaccard loss function
73	create network and compiler
74	cosine learning rate annealing
75	create train and validation generators
76	load and shuffle filenames
77	retrieve x , y , height and width
78	save dictionary as csv file
79	resize with random interpolation
80	Yoon Kim model
81	Original Yoon Kim model
82	create a submission
83	Data is still small enough for memory so read to memory using pandas
84	And finally lets look at the class distribution
85	The data is not balanced
86	Apply Underbalancing Techinique
87	The data is not balanced
88	import keras.backend as K
89	Take a look at predictions
90	fast less accurate
91	Ability to Detect Face
92	Loading data etc
93	update before matrix
94	value set for row n
95	column indices from set S in row k
96	Show and save column comparision matrix and save row sets
97	show uncertain comparisions
98	Find out which set stands before another
99	declare some parameter
100	code takesn from
101	load the image file using cv
102	grid mask augmentation
103	Preparing the training data
104	Training on the complete Dataset now
105	Data loading and checking
106	load master data
107	Unique value counts
108	Sales volume per year
109	raw price data
110	Sales volume per year
111	combine out df
112	combine out df
113	combine out df
114	combine out df
115	Training and score
116	Training and score
117	concat val data and eval data
118	FVC Progression by Sex
119	FVC Progression by SmokingStatus
120	Count occurance of words
121	this methods help to clean up some memory while improve the coverage
122	All contraction are known
123	Convert to lower case Clean contractions Clean special charactor Convert small caps
124	Daily percentage increase
125	Predict submission dates
126	Using LabelEncoding we just change string values to numbers
127	Using embedding in NN we can change dimensionality of categorical features
128	Prepare Traning Data
129	See sample image
130	See how our generator work
131	Prepare Testing Data
132	Create Testing Generator
133	Split the data into train and validation parts
134	Create and set up the model
135	Counting the metric score
136	Saving the model
137	You can state below link to your copy of this MMDetection repo
138	Make a simple restart of runtime at this point
139	Check mmcv installation
140	Sets the random seeds
141	Hist Graph of scores
142	get the data fields ready for stacking
143	fit the keras model on the dataset
144	get the data fields ready for stacking
145	I updated importation for a faster version
146	How many different values does our categorial variables take
147	Zoom on this IP
148	We can now take a first look at those IP
149	Does bots download the app
150	We create some categories to plot
151	We can plot it
152	Ok we can make our graph now
153	Ratio global analysis
154	Attributed time analysis
155	Download rate by hour
156	Importation of a entire day data
157	We can now print the results
158	Dealing with color
159	Deriving individual masks for each object
160	Create a random colormap
161	Check if the label size is too small
162	Get the object indices , and perform a binary opening procedure
163	Convert each labeled object to Run Line Encoding
164	Read in data and convert to grayscale
165	Mask out background and extract connected objects
166	Loop through labels and add each to a DataFrame
167	Only the classes that are true for each sample will be filled in
168	Exponential moving average of squared gradient values
169	Inter block part
170	Head of the model
171	Final part of the model
172	serialize model to JSON
173	set unique int value for each unique classes sring
174	resize the image
175	load images data and classes id
176	plot randam images
177	Size of each category
178	Price by category
179	So , some categories are expensive , but most are cheap
180	Now we can plot it
181	Prices of the first level of categories
182	We can now plot it
183	Brands sorted by number of item
184	Brands by price
185	What are their top categories
186	Does shipping depends of price
187	Can we get some informations out of the item description
188	What words do people use
189	Can the length of the description give us some informations
190	The full distribution
191	Is there a correlation between description length and price
192	Convert the original image to grayscale
193	Perform the blackHat filtering on the grayscale image to find the hair countours
194	intensify the hair countours in preparation for the inpainting
195	inpaint the original image depending on the mask
196	Convert the original image to grayscale
197	Perform the blackHat filtering on the grayscale image to find the hair countours
198	intensify the hair countours in preparation for the inpainting
199	inpaint the original image depending on the mask
200	from sklearn.manifold import TSNE
201	Graph Representation of RNA structure
202	Determine current pixel spacing
203	For every slice we determine the largest solid structure
204	Remove other air pockets insided body
205	Import Required Libraries
206	CONVERT DEGREES TO RADIANS
207	LIST DESTINATION PIXEL INDICES
208	ROTATE DESTINATION PIXELS ONTO ORIGIN PIXELS
209	FIND ORIGIN PIXEL VALUES
210	Determination categorical features
211	Encoding categorical features
212	Create mean column
213	Apply Logistic Regression
214	split training set to validation set
215	split training set to validation set
216	Standardization for regression models
217	Comparison of the all feature importance diagrams
218	MinMax scale all importances
219	Thanks to Automatic FE The main code for basic FE
220	FS with the Pearson correlation
221	Threshold for removing correlated variables
222	FS with SelectFromModel and LinearSVR
223	Parameters and LB score visualization
224	Find and mark maximum value of LB score
225	Interactive plot with results of parameters tuning
226	Interactive plot with results of parameters tuning
227	Interactive plot with results of parameters tuning
228	Ensembling the solutions and submission
229	Ensembling the solutions
230	Implementing the SIR model
231	Merge train and test , exclude overlap
232	Double check that there are no informed ConfirmedCases and Fatalities after
233	Create date columns
234	Filter selected features
235	Clean Id columns and keep ForecastId as index
236	Filter Spain , run the Linear Regression workflow
237	Filter Spain , run the Linear Regression workflow
238	Filter Italy , run the Linear Regression workflow
239	Filter Italy , run the Linear Regression workflow
240	Filter Germany , run the Linear Regression workflow
241	Filter Germany , run the Linear Regression workflow
242	Filter Albania , run the Linear Regression workflow
243	Filter Albania , run the Linear Regression workflow
244	Filter Andorra , run the Linear Regression workflow
245	Filter Andorra , run the Linear Regression workflow
246	Set the dataframe where we will update the predictions
247	Apply exponential transf
248	For boosting model
249	Support Vector Machines
250	Its also builds on kernel functions but is appropriate for unsupervised learning
251	Stochastic Gradient Descent
252	Decision Tree Regression
253	split training set to validation set
254	Gradient Boosting Regression
255	Extra Trees Regressor
256	Thanks for the example of ensemling different models from
257	Linear Regression model for basic train
258	Ridge Regression model for basic train
259	Parameters and LB score visualization
260	Find and mark maximum value of LB score
261	Interactive plot with results of parameters tuning
262	Interactive plot with results of parameters tuning
263	Set weight of models
264	Prepare Training Data
265	Standardization for regression models
266	DisplayName remove Outlier
267	PlayerCollegeName remove Outlier
268	Divide features into groups
269	concat all features
270	Set weight of models
271	from pykalman import KalmanFilter
272	configurations and main hyperparammeters
273	get lead and lags features
274	Code from notebook
275	My upgrade of parameters
276	sort the validation data
277	reorder the input data
278	Using my notebook
279	fit X and apply the reduction to X
280	Compute cluster centers and predict cluster indices
281	How many images are in each folder
282	Create a Dataframe containing all images
283	Balance the target distribution
284	these must match the folder names
285	these must match the folder names
286	Set Up the Generators
287	Here the best epoch will be used
288	What is the AUC Score
289	Create a Classification Report
290	MAKE A TEST SET PREDICTION
291	Set up the generator
292	Make a prediction on the test images
293	split into a list
294	Create a submission file
295	Create Binary Targets
296	Balance the target distribution
297	Train Test Split
298	destination path to image
299	destination path to image
300	Get a list of train and val images
301	destination path to image
302	destination path to image
303	Set Up the Generators
304	These weights can be changed later , if needed
305	Here the best epoch will be used
306	combine the train and test sets for encoding and padding
307	initialize the tokenizer
308	seperate the train and test sets
309	create a weight matrix
310	Define X and y
311	create a list of the target columns
312	Determination categorical features
313	Encoding categorical features
314	For boosting model
315	Support Vector Machines
316	Its also builds on kernel functions but is appropriate for unsupervised learning
317	Stochastic Gradient Descent
318	Decision Tree Regression
319	split training set to validation set
320	Gradient Boosting Regression
321	Extra Trees Regressor
322	Thanks for the example of ensemling different models from
323	call the first function
324	Load the pre processed data
325	load the pickled dataframes
326	Initialize patient entry into parsed
327	Add box if opacity is present
328	for patientId in batch
329	for patientId in batch
330	Reads images from a folder , converts the images to a numpy array
331	for patientId in batch
332	for patientId in batch
333	for patientId in batch
334	Initialize the generators
335	get the number of train and val images
336	Set the batch sizes
337	the same batch only once
338	Plot the Loss Curves
339	Make a Prediction
340	Process the Predictions
341	add column names
342	Create the submission csv file
343	What is a python generator
344	This is a simple example of a generator
345	How to make a generator run infinitely
346	This is how to do that
347	Thanks to Automatic FE The main code for basic FE
348	FS with the Pearson correlation
349	Threshold for removing correlated variables
350	FS with SelectFromModel and LinearSVR
351	FS with SelectFromModel and RandomForestRegressor
352	Load data files
353	Set up the folds for cross validation
354	Genetic program model , main code loop
355	Get the dupplicate clicks with different target values
356	Method to get image data as np.array specifying image id and type
357	Basic skin detection
358	Filter the skin mask
359	Apply skin mask
360	Apply skin segmentation on all training data and visualize the result
361	Some stats using jpg exif
362	Method to get image data as np.array specifying image id and type
363	For boosting model
364	For models from Sklearn
365	Support Vector Machines
366	Its also builds on kernel functions but is appropriate for unsupervised learning
367	Stochastic Gradient Descent
368	Decision Tree Regression
369	split training set to validation set
370	Gradient Boosting Regression
371	Extra Trees Regressor
372	Thanks for the example of ensemling different models from
373	Compute the STA and the LTA
374	Avoid division by zero by setting zero values to tiny float
375	Manager function to call the create features functions in multiple processes
376	mean absolute error
377	root mean squared error
378	mean absolute error
379	root mean squared error
380	Decode item length
381	Check if we can decode
382	How many different cars in train dataset
383	Define some constants for data location
384	Code from here and below is commented out because the kernel dies
385	Lets validate the test files
386	Decode item length
387	Check if we can decode
388	Idea is to use clustering on images of one type to group data
389	Find empty images
390	Set some parameters
391	Test on the data that is not seen by the network during training
392	Resize train images
393	The number of samples in each cluster is the following
394	Using DecisionTree Classifier
395	Confusion Matrix for Train Data Predictions
396	Confusion Matrix for Test Data Predictions
397	Using RandomForest Classifier
398	Confusion Matrix for Train Data Predictions
399	Confusion Matrix for Test Data Predictions
400	Converting the Input images to plot using plt
401	We iter the batch of images to display
402	Data load and process functions
403	CatBoost is RAM expensive so I prefer to utilize GPU
404	arrays needed for the iteration
405	evaluate fitness function for these possibilities
406	create a new dataframe to
407	of bayesian block bins
408	Word map for most frequent Tags
409	Featurization of Training Data
410	Fitting Logistic Regression with OneVsRest Classifier
411	using direct implementation of Logistic Regression
412	Importing Packages and Collecting Data
413	Importing Data Manipulattion Moduls
414	Seaborn and Matplotlib Visualization
415	Display markdown formatted output like bold , italic bold etc
416	Read the dataset from csv file
417	Variable Description and Identification
418	Train and test data at a glance
419	Dimension of train and test data
420	Meter Reading and Meter Type
421	Weekday and Meter Reading
422	Time of Day and Meter Reading
423	Primary Use and Meter Reading
424	Meter Readings over time
425	Meter Readings over time And Primary Use
426	Square feet size is positively Skewed
427	first column only
428	all other columns
429	Imputing Missing variable
430	Encoding Categorical Variable
431	Setting train , test and target for model
432	Prediction and Submission
433	Ignore deprecation and future , and user warnings
434	Import basic modules
435	Display markdown formatted output like bold , italic bold etc
436	Variable Description , Identification , and Correction
437	Train and Test data at a glance
438	Dimension of train and test data
439	Visulization of IntersectionID
440	Visulization of Path
441	Visualition of Map Plot of Atlanta city
442	Visualition of Map Plot of Boston city
443	Visualition of Map Plot of Philadelphia city
444	Visualition of Map Plot of Chicago city
445	Encoding Street Names
446	Encoding Cordinal Direction
447	Defineing the directions
448	Seting X and Y
449	Seting X and Y
450	Define search space of hyperparameters
451	Only the classes that are true for each sample will be filled in
452	For drawing onto the image
453	Adds a bounding box to an image
454	Load the downloaded and resized image and feed into the graph
455	see the sample image with bounding boxes
456	import required dependencies
457	Loading the data
458	A parameter grid for XGBoost
459	Here we go
460	Here we go
461	Here we go
462	Librairies and data
463	Data processing , metrics and modeling
464	MERGE , MISSING VALUE , FILL NA
465	cut tr and val
466	Roc curve by folds
467	Precion recall by folds
468	Loading the data
469	Data processing , metrics and modeling
470	MERGE , MISSING VALUE , FILL NA
471	Roc curve by fold
472	Precion recall by folds
473	Loading the data
474	Writing output to file
475	Create Document Vectors
476	encode another document
477	Document Vectors with TfidfVectorizer
478	Document Vectors with HashingVectorizer
479	Document Vectors with hashing trick
480	estimate the size of the vocabulary
481	Keras Tokenizer API
482	Activation functions are defined separately from layers
483	Creating the Model
484	Convolutional Neural Network
485	Sequence of two convolutional and pooling layers as feature extractors
486	Recurrent Neural Network
487	Importing The Dataset
488	Function for find out Numerical and categeical Variables
489	Types Of Features
490	Analysis based Averages values
491	Checking the Correlation Between The Features for Application Train Dataset
492	most correlated features
493	Merging the bureau dataset along with application train dataset to do more analysis
494	analyzing the numerical features disturbion in previous application dataset
495	Paths to data and metadata
496	Group signals metadata accroding to target
497	Apply reduction on some samples and visualize the results
498	read in header and get dimensions
499	handle .ahi files
500	Separate the zone and subject id into a df
501	show the graphs
502	Rescaling the Image Most image preprocessing functions want the image as grayscale
503	scale pixel values to grayscale
504	The lineplot of the date columns
505	The KDE of the numeric columns
506	One more by all counties
507	Split the train dataset into development and valid based on time
508	Interpreting ROC Plot
509	define a function that accepts a threshold and prints sensitivity and specificity
510	process remaining batch
511	calculates wins and losses to get winning percentage
512	a little housekeeping to make easier to graph correlation matrix
513	Lets calculate the number of games a team played in the conference tournament
514	Now lets do the same thing for the actual tourney
515	calculates the Conference RPI
516	Now we assign the Conference Strength back to each team
517	Convert string to an integer
518	quick and dirty to see how good a predictor Seed difference is
519	setup the data
520	use Logistic regression with Gridsearch for parameter tuning
521	gets the features for the winning team
522	gets the features for the losing team
523	reorder column to make it easier to group features together
524	Building the pipelines
525	First loop runs GridSearch and does Cross validation to find the best parameters
526	Generate predictions and probabilities
527	prints classification report and confusion matrix
528	Building the pipelines
529	First loop runs GridSearch and does Cross validation to find the best parameters
530	Generate predictions and probabilities
531	prints classification report and confusion matrix
532	Building the pipelines
533	First loop runs GridSearch and does Cross validation to find the best parameters
534	Generate predictions and probabilities
535	prints classification report and confusion matrix
536	Building the pipelines
537	First loop runs GridSearch and does Cross validation to find the best parameters
538	Generate predictions and probabilities
539	prints classification report and confusion matrix
540	Building the pipelines
541	First loop runs GridSearch and does Cross validation to find the best parameters
542	Generate predictions and probabilities
543	prints classification report and confusion matrix
544	This sets up the data so we can make predictions year by year
545	Lets test out the predictive power of the individual models themselves
546	Building the pipelines
547	First loop runs GridSearch and does Cross validation to find the best parameters
548	Generate predictions and probabilities
549	prints classification report and confusion matrix
550	Building the pipelines
551	First loop runs GridSearch and does Cross validation to find the best parameters
552	Generate predictions and probabilities
553	prints classification report and confusion matrix
554	Add RUC metric to monitor NN
555	Load data and fit some models
556	Creates a feature dictionary based on the features present in the LGBM model
557	Plot Gain importances
558	Create ordered dict to perform and easy sort
559	Replace values in the dict
560	Plot Gain importances
561	number of nan values in each column
562	Bounded region of parameter space
563	len of description
564	int in description
565	predicting and saving to output file
566	loss function definition courtesy
567	A simple Keras implementation that mimics that of
568	Lets Read In Data Files
569	When Do People Generally Order
570	At What Day Of The Week People Order
571	When Do People Generally Reorder
572	How many orders users generally made
573	Visuallizing Interest Level Vs Bathroom
574	Visualizing Interest Level Vs Bedrooms
575	Correlation Between Price and Other Features
576	Main Config Variables
577	Extract data from dataframe
578	Calculate spectrogram using pytorch
579	Calculate logmel spectrogram using pytorch
580	Logmel feature extractor
581	in smaller ones
582	Or models are blend with simple Mean
583	Or models are blend with simple Mean
584	Create final submission DF
585	No Of Storey Over The Years
586	Bedroom Count Vs Log Error
587	Bathroom Count Vs Log Error
588	Room Count Vs Log Error
589	No Of Storeys Vs Log Error
590	Gaussian Noise on Target
591	Composition of Augmentations
592	Loading and preprocessing data
593	Preprocessing of features
594	Text Processing of text data easily
595	select running device
596	if not bird
597	Let us read the masks
598	So a unique operator will give us the unique filenames that contain ships
599	Let us load one image and its masks
600	Now we can read the masks for the specific image
601	For the same window we superimpose the masks above the image
602	Read necessary files and folders
603	Y is the target
604	Read all training files and keep them in memory
605	Nice helper functions for padding , random sampling L samples
606	Only the classes that are true for each sample will be filled in
607	Return a normalized weight vector for the contributions of each class
608	add filename relative to directory
609	optionally save augmented images to disk for debugging purposes
610	add filename relative to directory
611	optionally save augmented images to disk for debugging purposes
612	Prediction on test set
613	Any results you write to the current directory are saved as output
614	Weight of the class is inversely proportional to the population of the class
615	An optimizer for rounding thresholds
616	add some noise to reduce overfitting
617	reduce amount of data to speed things up
618	Cycle through contours and add area to array
619	Cycle through contours and add area to array
620	Cycle through contours and add area to array
621	Cycle through contours and add area to array
622	Super cool Dataset from
623	Replacing Mainland china with just China
624	Now a look at Italy
625	Comparison between Brazil and Italy
626	China scenario since first entry
627	Spain since first recorded case
628	Iran since first case
629	USA since first case
630	SIR model that takes into account the number of deaths
631	A modified SEIRD model in order to take into account quarantine
632	Getting population for each country
633	Select the models to run setting bool variables below
634	Calculating the day when the number of infected individuals is max
635	Defining the deterministic formulation of the problem
636	Defining the deterministic formulation of the problem
637	Lets gets started
638	Full data Analysis
639	Seperating the data into different data frame based on the labels
640	most important or common positive words
641	Most important or common negative words
642	Most important or common words in neutral data
643	pip install transformers
644	and target vector that correspond to the test data size
645	Number of tries for each group of samples
646	Draw means for each group
647	Import Packages and Functions
648	Load and Explore Data
649	Create the embedding layer
650	Build the Model
651	create a submission
652	packages for visualiztion and exploratory analysis
653	function to read training data into pandas dataframe
654	function to read test data into pandas dataframe
655	Imputing missing values
656	combining categorical attributes from training and test datasets
657	data preparation for modeling and prediction steps
658	Random Forest Regressor
659	Feature Agglomeration Results
660	Computes and stores the average and current value
661	Predict on test set
662	Bookings per day of week
663	Bookings by year
664	Bookings by month
665	Interactive booking , click , and percentage of booking trends with Bokeh
666	expanding the aggregate
667	a quick check if demand distribution changes week to week
668	Read the csv files from kaggle
669	Read the csv files on the Johns Hopkins CSSE database on github
670	Transpose the dataframes
671	Join all dataframes
672	define list of models and parameters
673	join all features
674	define training and validation sets
675	run grid search
676	save the forecast
677	filtering out outliers
678	using outliers column as labels instead of target column
679	Check Unique Label
680	get unique labels
681	convert unicode to str
682	convert unicode to str
683	convert unicode to str
684	convert unicode to str
685	convert unicode to str
686	sample n pictures
687	Get a sample from the dataset
688	Draw bounding box around character , and unicode character next to it
689	functions to show an image
690	get some images
691	Computes gradient of the Lovasz extension w.r.t sorted errors
692	Non physical data augmentation
693	This will load a stored trained model or the last trained model
694	remove layter activation layer and use losvasz loss
695	remove layter activation layer and use losvasz loss
696	Exclude background from the analysis
697	Precision helper function
698	Check if valid data looks all right
699	ONLY TRAIN WITH DATA WHERE WHEEZY EQUALS I
700	MODEL AND PREDICT WITH QDA
701	ONLY TRAIN WITH DATA WHERE WHEEZY EQUALS I
702	ADD PSEUDO LABELED DATA
703	STRATIFIED K FOLD
704	MODEL AND PREDICT WITH QDA
705	ONLY TRAIN WITH DATA WHERE WHEEZY EQUALS I
706	MODEL AND PREDICT WITH QDA
707	PRINT CV AUC
708	Use Private as Pseudo Label to see LB
709	STRATIFIED K FOLD
710	PRINT CV AUC
711	ONLY TRAIN WITH DATA WHERE WHEEZY EQUALS I
712	ADD PSEUDO LABELED DATA
713	STRATIFIED K FOLD
714	missing value statistics
715	y的异常值 drop samples which have exception value in y
716	Train model with continuous value
717	y hist with defferent timestamps are similar
718	LOAD model , preprocess
719	Save objects for next step
720	Import necessary libraries
721	High cardinality features
722	Ordinal features mapping
723	Replace a character with its ASCII value
724	Impute numeric features with mean value and normalize afterward
725	Predict test set and make submission
726	show one image
727	Remove Extreme Prices
728	Use Ad Image to Identify Item Category
729	Price Variance Within Identified Items
730	Extracting previous click feature
731	Affected Surface Object
732	Detect and compute interest points and their descriptors
733	Detect and compute interest points and their descriptors
734	Classify image and return top matches
735	Classify an image with different models
736	All Zero Features
737	Show Original Image
738	choose a random image
739	ratio between line distance and curve distance
740	a little move
741	deform whole image by deform each strokes
742	Start by pivoting the DataFrame to explore the label distribution over slices
743	this method also handles duplicates gracefully
744	As a Neuroradiologist , this distribution looks pretty true to daily practice
745	build a dict to convert surface names into numbers
746	Creating in Label
747	freeze layers only if pretrained backbone is used
748	Load the trained weights
749	Demonstration how it works
750	Combinations of TTA
751	Set a few plotting defaults
752	Read in Data and Look at Summary Information
753	Read in data
754	Plot each poverty level as a separate line
755	Fill in the values with the correct mapping
756	Plot each poverty level as a separate line
757	Bar plot of occurrences of each label
758	Addressing Wrong Labels
759	Families without Heads of Household
760	Select heads of household
761	Plot of the home ownership variables for home missing rent payments
762	Scatter plot sized by percent
763	Put text with appropriate offsets
764	sizes for legend
765	Markers for legend
766	Legend and formatting
767	Redundant Household Variables
768	Creating Ordinal Variables
769	Roof ordinal variable
770	Owns a refrigerator , computer , tablet , and television
771	Per Capita Features
772	In most cases , the values are very similar
773	Use only training data
774	Calculate spearman correlation
775	Draw a correlation heatmap
776	Create the pairgrid object
777	Bottom is density plot
778	Redundant Individual Variables
779	For example , we can divide the years of schooling by the age
780	Feature Engineering through Aggregations
781	Next we can rename the columns to make it easier to keep track
782	Rename the columns
783	Machine Learning Modeling
784	The data has no missing values and is scaled between zero and one
785	Normalize the feature importances to add up to one and calculate cumulative importance
786	Bar plot of n most important features
787	Cumulative importance plot
788	Add vertical line to plot
789	Filter out warnings from models
790	Comparing Model Performance
791	Train on the data
792	Make a submission dataframe
793	Recursive Feature Elimination with Random Forest
794	Convert back to dataframe
795	Using early stopping so do not need number of esimators
796	Build the model
797	Convert to arrays for indexing
798	Training and validation data
799	Train with early stopping
800	Feature importances dataframe
801	Find the class and associated probability
802	Find the class and associated probability
803	Plot the confidence by each target
804	Retrieve the subsample
805	Subsample and subsample frequency to top level keys
806	Make sure parameters that need to be integers are integers
807	Convert to arrays for indexing
808	Training and validation data
809	Train with early stopping
810	Record the validation fold score
811	Create a file and open a connection
812	Write column names
813	Plot the predicted labels
814	Split into validation set
815	Create model and train
816	Convert into predictions
817	TSNE has no transform method
818	Add components to test data
819	Add components to training data for visualization and modeling
820	Visualize Tree with No Maximum Depth
821	No maximum depth
822	Read the image on which data augmentaion is to be performed
823	Custom Cutout augmentation with handling of bounding boxes
824	Applies the cutout augmentation on the given image
825	Set to instance variables to use this later
826	Read the image on which data augmentaion is to be performed
827	Read the image on which data augmentaion is to be performed
828	Read the image on which data augmentaion is to be performed
829	Read the image on which data augmentaion is to be performed
830	Lets first check the Train Target Distribution
831	Filling missing and infinite data by zeroes
832	Submitting our Predictions
833	Data Exploration and Data Cleaning
834	Empirical Cumulative Distribution Function Plot
835	Remove latitude and longtiude outliers
836	Rides on Map of NYC
837	Adjust alpha of legend markers
838	Plot the pickups
839	Adjust alpha of legend markers
840	Calculate distribution by each fare bin
841	Calculate distribution by each fare bin
842	The test distribution seems to be similar to the training distribution
843	Create Training and Validation Set
844	Train with Simple Features
845	Account for y values of
846	Create list of the same prediction for every observation
847	Use More Features
848	Create the random forest
849	Extract feature importances
850	Check the time
851	Add seconds since start of reference
852	Explore Time Variables
853	We can make the same plot by day of the week
854	Plot each of the fractional times
855	Test Time Features
856	Try with All Time Variables
857	Visualize Validation Predicted Target
858	Plot the ecdfs on same plot
859	Create the random search model
860	Evaluate Best Model from Random Search
861	Split into training and testing data
862	Standard deviation of best score
863	Now we can evaluate the baseline model on the testing data
864	Train and make predicions with model
865	Make sure parameters that need to be integers are integers
866	boosting type domain
867	Extract the boosting type
868	Example of Sampling from the Domain
869	Create a new file and open a connection
870	Write column names
871	Test the objective function
872	Create a file and open a connection
873	Write column names
874	Train and make predictions
875	Iterate through each set of hyperparameters that were evaluated
876	Put the iteration and score in the hyperparameter dataframe
877	Learning Rate Distribution
878	Dataframe of just scores
879	Iterate through each hyperparameter
880	Applied to Full Dataset
881	Extract the test ids and train labels
882	Random Search on the Full Dataset
883	Bayesian Optimization on the Full Dataset
884	Standard imports for data science work
885	matplotlit and seaborn for visualizations
886	Read in data
887	Original features will be in both datasets
888	Now we want to combine the data without creating any duplicate rows
889	Match the columns in the dataframes
890	Identify Correlated Variables
891	Drop Correlated Variables
892	Identify missing values above threshold
893	Need to save the labels because aligning will remove this column
894	Make sure to average feature importances
895	Find the features with zero importance
896	Need to reverse the index to plot most important on top
897	Cumulative importance plot
898	Find the features with zero importance
899	One Hot Encoding
900	Catch error if label encoding scheme is not valid
901	Create the model
902	Train the model
903	Record the best score
904	Clean up memory
905	Dataframe of validation scores
906	Plot the cumulative variance explained
907	Return size of dataframe in gigabytes
908	Remove id variables other than grouping variable
909	Only want the numeric variables
910	Remove the columns with all redundant values
911	Remove duplicate columns by values
912	Combined Aggregation Function
913	Aggregate the categorical variables at the parent level
914	Aggregate the categorical variables at the grandparent level
915	Drop the columns with all duplicated values
916	Merge with the main dataframe
917	Aggregate previous loans at Home Credit
918	Aggregate Installments Data
919	Aggregate Cash previous loans
920	Aggregate Credit previous loans
921	Normalize the feature importances to add up to one
922	Bar plot of n most important features
923	Cumulative importance plot
924	Add vertical line to plot
925	Train and make predicions with model
926	Hyperparameter Tuning Implementation
927	results to retun
928	Set subsample depending on boosting type
929	Learning Rate Domain
930	Dataframes for random and grid search
931	Grid Search Implementation
932	Evalute the hyperparameters
933	Sort with best score on top
934	Create , train , test model
935	Sort with best score on top
936	Create , train , test model
937	Create file and open connection
938	Write column names
939	Dataframe for results
940	Sort with best score on top
941	Evalute the hyperparameters
942	Sort with best score on top
943	Train and make predictions
944	Iterate through each set of hyperparameters that were evaluated
945	Put the iteration and score in the hyperparameter dataframe
946	First , we need to put our data into a long format dataframe
947	Combine results into one dataframe
948	Distribution of Search Values
949	Density plots of the learning rate distributions
950	Iterate through each hyperparameter
951	Testing Results on Full Data
952	Extract the test ids and train labels
953	matplotlit and seaborn for visualizations
954	Add identifying column
955	Entities with a unique index
956	Entities that do not have a unique index
957	Relationships between previous apps and cash , installments , and credit
958	List the primitives in a dataframe
959	DFS with Default Primitives
960	DFS with specified primitives
961	DFS with default primitives
962	DFS with Selected Aggregation Primitives
963	Specify the aggregation primitives
964	Visualize Distribution of Correlated Variables
965	Need to reset index for loc to workBU
966	Label the plots
967	Need to reverse the index to plot most important on top
968	Remove Low Importance Features
969	Align Train and Test Sets
970	Align dataframes on the columns
971	Read in data and sort
972	Kdeplot of model scores
973	Distribution of Scores
974	Iterate through each set of hyperparameters that were evaluated
975	Put the iteration and score in the hyperparameter dataframe
976	Plots of Hyperparameters vs Score
977	First we need to format the data and extract the labels
978	Need to reverse the index to plot most important on top
979	Properly Representing Variable Types
980	Record ordinal variables
981	Replace all the day outliers
982	Convert to timedelta in days
983	Create the date columns
984	Drop the time offset columns
985	Select one loan and plot
986	Make date columns
987	Drop the time offset columns
988	Select on loan and plot
989	Create time column and drop
990	Select one loan and plot
991	Entities with a unique index
992	Relationships between previous apps and cash , installments , and credit
993	Calculate the features with intereseting values
994	Plot of client type when contract was approved
995	Plot of client type where contract was refused
996	DFS with seed features
997	DFS with specified seed feature
998	Divide the occurences of mode by the total occurrences
999	Iterate through the iterable
1000	DFS with custom features
1001	Return the most recent occurence
1002	DFS with custom feature
1003	Putting it all Together
1004	Run and create the features
1005	Run and create the features
1006	Remove low information features
1007	Calculate medians for repaid vs not repaid
1008	Correlations of Aggregated Values with Target
1009	Remove id variables other than grouping variable
1010	Make a new column name for the variable and stat
1011	Function to Handle Categorical Variables
1012	Make a new column name
1013	Putting the Functions Together
1014	Free up memory by deleting old objects
1015	Read in new copies of all the dataframes
1016	Aggregated Stats of Bureau Balance by Client
1017	Sort the table by percentage of missing descending
1018	Print some summary information
1019	Calculate Information for Testing Data
1020	Track columns to remove and columns already examined
1021	Keep track of columns already examined
1022	Only want to remove one in a pair
1023	One Hot Encoding
1024	Catch error if label encoding scheme is not valid
1025	Create the model
1026	Train the model
1027	Record the best score
1028	Clean up memory
1029	Dataframe of validation scores
1030	Need to reverse the index to plot most important on top
1031	Suppress warnings from pandas
1032	Remove id variables other than grouping variable
1033	Only want the numeric variables
1034	Remove the columns with all redundant values
1035	Remove duplicate columns by values
1036	Calculate medians for repaid vs not repaid
1037	Return size of dataframe in gigabytes
1038	Calculate aggregate statistics for each numeric column
1039	Calculate value counts for each categorical column
1040	Merge in the previous information
1041	Remove variables to free memory
1042	Sort the table by percentage of missing descending
1043	Print some summary information
1044	Drop the missing columns and return
1045	Merge the numeric and categorical
1046	Merge to get the client id in dataframe
1047	Monthly Cash Data
1048	Monthly Credit Data
1049	One Hot Encoding
1050	Catch error if label encoding scheme is not valid
1051	Create the model
1052	Train the model
1053	Record the best score
1054	Clean up memory
1055	Dataframe of validation scores
1056	Split into training and validation groups
1057	eturn img , mask
1058	Prediction for one image
1059	predict and show prediction
1060	Train and validate
1061	create the encoder pathway and add to a list
1062	encoder pathway , save outputs for merging
1063	We will use the most basic of all of them
1064	Generate data for the BERT model
1065	Model Hyper Parameters
1066	First dense layer
1067	split training and validation data
1068	Print CV scores , as well as score on the test data
1069	Write the prediction to file for submission
1070	Continue with the original code
1071	You can access the actual face itself like this
1072	You can access the actual face itself like this
1073	Granted applications per number of children
1074	Income distribution and target value
1075	Read the data
1076	Check the typical length of a comment
1077	Convert to lower case , split into individual words
1078	Set values for various parameters
1079	vocaublary , add its feature vector to the total
1080	Divide the result by the number of words to get the average
1081	we use a partial fit approach
1082	Parser for Salt Competition
1083	Initialize processing by loading .csv files
1084	Specify if image should be loaded in grayscale
1085	Resize or pad image and mask
1086	Output information about training set
1087	because each coverage will occur only once
1088	score will be bad
1089	They must be resized again to their original size before encoding
1090	Perform mask predictions binarization and RLEncoding
1091	Submission generation based on encoded model predictions
1092	Define helper functions
1093	Input dictionary for SaltParser
1094	for model training
1095	Predict validation and test set masks
1096	This can be optimized
1097	Helper variable to index oof
1098	Create train and validation sets based on KFold indices
1099	Predict validation and test data and store them in oof sets
1100	Show best AUC per fold based on GBM training history
1101	Train the LGBM model
1102	Prepare submission format and save it
1103	Loading the data
1104	and batch aggregations examples for the rest of the tables ..
1105	load mapping dictionaries
1106	Load metadata file
1107	Load sentiment file
1108	Load image file
1109	Unique IDs from train and test
1110	Extract processed data and format them as DFs
1111	Extract processed data and format them as DFs
1112	extract different column types
1113	Subset text features
1114	Remove missing target column from test
1115	Check if columns between the two DFs are the same
1116	Returns the counts of each type of rating that a rater made
1117	Compute QWK based on OOF train predictions
1118	Manually adjusted coefficients
1119	Distribution inspection of original target and predicted train and test
1120	Rename columns after grouping for easy merge and access
1121	Prepare for training
1122	LGB model parameters
1123	Create Dataset objects for lgb model
1124	Save predictions for each fold
1125	Sigmoid over final convolution map is needed for Binary Crossentropy loss
1126	Load mask for training or evaluation
1127	Initialize train and test DataFrames to access IDs and depth information
1128	Percent of area covered by mask
1129	Set data loading parameters
1130	Pin memory for quicker GPU processing
1131	Do not shuffle for validation and test
1132	Put prediction on CPU , detach it and transform to a numpy array
1133	Cut off padded parts of images
1134	Perform check on randomly chosen mask and prediction
1135	From timestamps set
1136	Create DFs imitating public and private test subsets
1137	Distribution of months in train and test
1138	SHAP Interaction Values
1139	Raw dependence plot
1140	Interaction values dependence plot capturing main effects
1141	Interaction values dependence plot capturing interaction effects
1142	Get important features according to SHAP
1143	Add need fields
1144	Exponential Growth Curves
1145	Gaussian Approximation of Active Cases
1146	load mapping dictionaries
1147	Unique IDs from train and test
1148	Image size for training
1149	Choose proper preprocessing function for model
1150	but avoid situations where pet is completely removed from the crop
1151	Initialize training data generator
1152	Initialize validation data generator
1153	inspect datagen output
1154	into this form
1155	Create strategy from tpu
1156	watch out for overfitting
1157	numpy and matplotlib defaults
1158	size and spacing
1159	LIST DESTINATION PIXEL INDICES
1160	ROTATE DESTINATION PIXELS ONTO ORIGIN PIXELS
1161	FIND ORIGIN PIXEL VALUES
1162	Order does not matter since we will be shuffling the data anyway
1163	Order does not matter since we will be shuffling the data anyway
1164	This images from validation data seem to be really strange labeled ...
1165	Placeholders for global statistics
1166	Process test data in parallel
1167	Load Packages and Data
1168	Outlier Analysis and Feature Scaling
1169	Just a check of the dimensions
1170	del X , y , cols , tscv
1171	render gif and cleanup
1172	vtk reading dicom
1173	convert to HU
1174	and background color definition
1175	Add the actors to the renderer , set the background and size
1176	render gif and cleanup
1177	Set the furniture colors
1178	OSIC training data Example
1179	compute the new values of the confusion matrix
1180	update the values in the original confusion matrix
1181	Normalize the confusion matrix and outer product
1182	Calculate Kappa score
1183	Returns the serializable config of the metric
1184	Resets all of the metric state variables
1185	elif train , needs to be passed throught this clausule
1186	how many actions the player has done
1187	the previous are scraped
1188	Generate average accuracy of each assessment
1189	unique title list
1190	unique event code list
1191	Predict Test Set and Submit Result
1192	Numeric as float
1193	Predict out of fold
1194	Predict on train using all train for each fold
1195	Predict on test set based on current fold model
1196	Save current fold values
1197	Build new dataframe
1198	Create temporary dataframe
1199	Plot validation loss
1200	Plot box plot of RMSE
1201	TPU Strategy and other configs
1202	Load Model into TPU
1203	Create fake filepaths dataframe
1204	First downsize all the images
1205	Create real file paths dataframe
1206	Load and freeze DenseNet
1207	The data , split between train and test sets
1208	Creating and Training the Model
1209	Save model and weights
1210	Padding process and resizing with OpenCV
1211	Pad and resize all the images
1212	Start with negative target
1213	Create strategy from tpu
1214	Order does not matter since we will be shuffling the data anyway
1215	Only load those columns in order to save space
1216	Group and Reduce
1217	and reduced using summation and other summary stats
1218	Additional stats on group
1219	Adding mode as feature
1220	Drop target , fill in NaNs
1221	Compute best params and its corresponding score
1222	This method expands a dictionary of lists into
1223	Refit and Submit
1224	select proper model parameters
1225	Make a picture format from flat vector
1226	Plotting some random images to check how cleaning works
1227	Load and process data
1228	Load text data into memory
1229	Build datasets objects
1230	Load model into the TPU
1231	Create fast tokenizer
1232	Load text data into memory
1233	Build datasets objects
1234	Load model into the TPU
1235	Adds a bounding box to an image
1236	Reverse list and print from bottom to top
1237	Create our inference graph
1238	Initialize the Session
1239	Run the graph we just created
1240	Inference on Test Set
1241	Load the image string
1242	Run our session
1243	we have to truncate it
1244	Load and preprocess data
1245	so that it can be used as an input in keras
1246	Evaluate training history
1247	to truncate it
1248	Load and preprocess data
1249	Unhide below to see all trials results
1250	Save model and best hyperparams
1251	Retrieve desired category
1252	Restore previously trained model
1253	Train model only on data for specific category
1254	Make prediction and add to output dataframe
1255	Load Model into TPU
1256	Will need those folders later for storing our jpegs
1257	Create new labels
1258	Pad and resize all the images
1259	Using original generator
1260	Combine the filename column with the variable column
1261	Create test generator
1262	Reducing Image Size
1263	Using original generator
1264	Save results as CSV files
1265	Training the model
1266	Load Test dataframe
1267	Infer using trained model
1268	Comparing various kappa scoring
1269	else use the most frequent pixel color
1270	identify obeject by the color only
1271	identify all objects by physical isolation on the given image
1272	delete the checked pairs from current object pairs
1273	start identifying a new object
1274	identify objects first by color then by physical isolation
1275	identify objects by isolation in this color only
1276	iterate through training examples
1277	identify objects only by color
1278	identify objects only by isolation
1279	identify objects by color and isolation
1280	Relevant attributes of identified objects are stored
1281	Import the modules
1282	Other columns are the digital value of pixels of kannada mnist
1283	Extract the label from training dataframe and discard the label column
1284	Convert dataframe into numpy array
1285	list to save all the models we are going to train
1286	Drop the blurry image
1287	Display the dropped images
1288	Load dataset info
1289	Determine proper input shape
1290	squeeze and excite block
1291	squeeze and excite block
1292	warm up model
1293	Load dataset info
1294	warm up model
1295	creating df with train labels
1296	augmentation settings , for now just normalizing
1297	preparing testing data
1298	Creating submission file
1299	Function for coding language information
1300	Function for cutting off the middle part of long texts
1301	Build the original and translated test data
1302	Predict with pure text models
1303	Predict with mixed language models
1304	Clear up the memory first
1305	Ensemble with my historical best
1306	This is a simple modify from
1307	Dequantize the feature from the byte format to the float format
1308	Pick some frames to display
1309	sess.run to get data in numpy array
1310	Get feature importances
1311	Display current run and time used
1312	Split Trian and Valid
1313	plot feature importance
1314	This plot shows summarized information about feature impact against shap output
1315	use atomic numbers to recode atomic names
1316	downcast back to int
1317	Set up GPU preferences
1318	Loop through each molecule type
1319	Split all our input and targets by train and cv indexes
1320	downcast back to int
1321	Set up GPU preferences
1322	Split all our input and targets by train and cv indexes
1323	Parameters for an individual model block
1324	Change namedtuple defaults
1325	Calculate and round number of filters based on depth multiplier
1326	Round number of filters based on depth multiplier
1327	Convolutions like TensorFlow , for a fixed image size
1328	Gets a block through a string notation of arguments
1329	Encodes a block to a string
1330	Encodes a list of BlockArgs to a list of strings
1331	Loads pretrained weights , and downloads if loading for the first time
1332	Depthwise convolution phase
1333	Squeeze and Excitation layer , if desired
1334	Expansion and Depthwise Convolution
1335	Squeeze and Excitation
1336	Skip connection and drop connect
1337	Update block input and output filters based on depth multiplier
1338	The first block needs to take care of stride and filter size increase
1339	Final linear layer
1340	samples with good confidence
1341	for figure Legend
1342	This function takes a row and return signal to noise
1343	Plotting errors for one sample
1344	train solved tasks
1345	evaluation solved tasks
1346	All train tasks predictions
1347	iterate through all the columns of a dataframe and modify the data type
1348	Fast data loading
1349	Leak Data loading and concat
1350	iterate through all the columns of a dataframe and modify the data type
1351	Fast data loading
1352	Leak Data loading and concat
1353	iterate through all the columns of a dataframe and modify the data type
1354	Fast data loading
1355	iterate through all the columns of a dataframe and modify the data type
1356	meter split based
1357	Find Best Weight
1358	iterate through all the columns of a dataframe and modify the data type
1359	Fast data loading
1360	Leak Data loading and concat
1361	what already is known
1362	make hour column from transactionDT
1363	At first , I made Europe future
1364	There is a gap between them
1365	Downloading the shapefile of the area
1366	Loading to a geopandas dataframe
1367	Ploting the data
1368	Function that add the tile background to the map
1369	Adding the name of the districts
1370	Encoding the Categorical Variables
1371	Creating the model
1372	Submitting the results
1373	Model Evaluation and Validation
1374	Drop target , fill in NaNs
1375	They are very similar to each other
1376	Importing Library Files
1377	OUTPUT OF AUGMENTATED IMAGES
1378	loads images in a mosaic
1379	Combined rotation matrix
1380	create new boxes
1381	split the dataset in train and test set
1382	Remove Commonly used Words
1383	Train and validate Split
1384	Convert to Numpy array
1385	suppose all instances are not crowd
1386	These are needed as well by the efficientdet model
1387	Apply some augmentation on the fly
1388	Need yxyx format for EfficientDet
1389	to find a better one
1390	This is the transforms for the training phase
1391	left and lower right corners
1392	Save as parquet file
1393	or maybe I am missing something
1394	Filtering images with at least one mask
1395	Plotting for only few molecules
1396	Then transform to a datetime object supposing that it is an ordinal datetime
1397	Most of the dates overlap
1398	Finish implementing this ..
1399	Should there be scale transformation
1400	Should there be scale transformation
1401	unlog the data , clip the negative part if smaller than
1402	Why does that start
1403	Two years was too much for the RAM ..
1404	check the time frame
1405	Rolling monthly and yearly store means
1406	Get just the digits from the seeding
1407	Train Our Linear Regression Model
1408	Next , we will make prediction with our LR Model
1409	Sampling the train data since too much data
1410	Try other columns to experiment
1411	How it should look
1412	targets in labels.csv
1413	targets in train.csv
1414	These labels are not in train
1415	Number of labels for each instance
1416	TPU Strategy and other configs
1417	Get Model into TPU
1418	Loading and Visualization of Data
1419	importing the dependencies
1420	importing classes helpfull for text processing
1421	Making Vocabulary and Text Conversion
1422	making a list of total sentences
1423	no hyphens and other special characters , split into words
1424	tokenising the lowered corpus
1425	tokens and its count
1426	length of largest sentence , and that of the smallest
1427	feature vector for each word we need to do this
1428	Making Feature Matrices
1429	first we make the training set
1430	now we make the testing set
1431	saving the numpy arrays
1432	Count game trainsition
1433	Visualize by heatmap
1434	mode , if unk is set we are doing it for unknown files
1435	View Single Image
1436	Number of Patients and Images in Training Images Folder
1437	Number of Patients and Images in Test Images Folder
1438	Create Image Augmentation Generator
1439	Get Tabular Data
1440	process training images
1441	process test images
1442	process submission images
1443	we add some squared features for some model flexability
1444	squared features for some model flexability
1445	try moving value up
1446	Order does not matter since we will be shuffling the data anyway
1447	Submission from mode
1448	Split into train and test sets
1449	Convert an array of values into a dataset matrix
1450	Create dataset with look back
1451	Make prediction and apply invert scaling
1452	Using all features for model training
1453	Drop rows with NaN values
1454	Invert scaling for forecast
1455	Invert scaling for actual
1456	These have their kitchen area larger than the total area of the house
1457	checking missing data
1458	checking missing data
1459	checking missing data
1460	checking missing data
1461	Make a Baseline model
1462	Create dataset for training and Validation
1463	CNN Model for multiclass classification
1464	Create Inference Dataset
1465	Define dataset and model
1466	Prediction for test
1467	we assign frequency of zero to them
1468	calculate the highest numerical value used for numeric encoding
1469	split the binary representation into different bit of digits
1470	perform scaling if required i.e
1471	Order does not matter since we will be shuffling the data anyway
1472	size and spacing
1473	MAKE CUTMIX LABEL
1474	Compare timing for CutMix
1475	MAKE MIXUP IMAGE
1476	MAKE CUTMIX LABEL
1477	Compare timing for MixUp
1478	LIST DESTINATION PIXEL INDICES
1479	ROTATE DESTINATION PIXELS ONTO ORIGIN PIXELS
1480	Compare timing for GridMask
1481	Plot distribution among different province
1482	For local usage
1483	Hugging Face pretrained Bert model names
1484	Make TF record file for test dataset
1485	Convert test examples to tf records
1486	Choose the model to use
1487	if a checkpoint exists , restore the latest checkpoint
1488	Eval data available for a single example
1489	Read candidates from a single jsonl file
1490	Read candidates with real multiple processes
1491	Construct prediction objects
1492	Run on validation dataset
1493	Get metrics for validation dataset
1494	Run on test dataset
1495	For local usage
1496	Hugging Face pretrained Bert model names
1497	Choose the model to use
1498	Get variables to apply weight decay in AdamW optimizer
1499	if a checkpoint exists , restore the latest checkpoint
1500	Check saved checkpoints
1501	Detect hardware , return appropriate distribution strategy
1502	Order does not matter since we will be shuffling the data anyway
1503	of the TPU while the TPU itself is computing gradients
1504	LIST DESTINATION PIXEL INDICES
1505	ROTATE DESTINATION PIXELS ONTO ORIGIN PIXELS
1506	FIND ORIGIN PIXEL VALUES
1507	Iterate over the whole training dataset
1508	Iterate over the whole training dataset
1509	LIST DESTINATION PIXEL INDICES
1510	ROTATE DESTINATION PIXELS ONTO ORIGIN PIXELS
1511	An example usage
1512	size and spacing
1513	Order does not matter since we will be shuffling the data anyway
1514	size and spacing
1515	For local usage
1516	Detect hardware , return appropriate distribution strategy
1517	Get labels and their countings
1518	Get labels and their countings
1519	Define the number of repetitions for each class
1520	LIST DESTINATION PIXEL INDICES
1521	ROTATE DESTINATION PIXELS ONTO ORIGIN PIXELS
1522	FIND ORIGIN PIXEL VALUES
1523	Check oversampled dataset
1524	Eval data available for a single example
1525	Span logits minus the cls logits seems to be close to the best
1526	Default empty prediction
1527	Computes official answer key from raw logits
1528	Join examples with features and raw results
1529	Read candidates with real multiple processes
1530	Min payment for all previous loans
1531	Sum and mean of minimum payments across all previous loans
1532	Random Forest model
1533	Plot the mean ROC
1534	Plot the standard deviation around the mean ROC
1535	Load the data
1536	Check the data
1537	Data transformation and helper functions
1538	In this implementation I will skip all the datapoint with actual is null
1539	create testing series
1540	This is to demo the median model
1541	This is to demo the ARIMA model
1542	This is to demo the facebook prophet model
1543	if there is too many zero , just use normal is OK
1544	Inplace or Copy
1545	Use column name
1546	Generate date features
1547	Inplace or Copy
1548	Add weather info
1549	Add weather hourly
1550	Week of year average
1551	Day of month average
1552	Day of year average
1553	Day week average
1554	Train a model
1555	Train a model
1556	For data prep
1557	Creation of the External Marker
1558	Creation of the Watershed Marker
1559	do here two charts density distribition
1560	Show influence of economical factors on housing prices
1561	Choose significant macroeconomical features by their correlation
1562	Best parameters are searched by GridSearchCV on my Laptop
1563	Set Model for prediction
1564	Test data preparation
1565	from tensorflow.keras import layers as L
1566	Data preparation for test
1567	Pinball loss for multiple quantiles
1568	Pinball loss for multiple quantiles
1569	range of variables
1570	Convert DCM to PNG
1571	The model with the lowest validation loss
1572	Predictions class distribution
1573	Get the categorical and numeric columns
1574	Check the dataset
1575	load prepared train data and test data
1576	Check null data
1577	Make new features using continuous feature
1578	Ratio feature can have infinite values
1579	wall and roof
1580	wall and floor
1581	roof and floor
1582	combination using three features
1583	Mix region and education
1584	Remove feature with only one value
1585	fill all na as
1586	Remove useless feature to reduce dimension
1587	Feature selection using shap
1588	this follows the discussion in
1589	to truncate it
1590	Load and preprocess data
1591	loss for noisy test data
1592	some config values
1593	fill up the missing values
1594	Tokenize the sentences
1595	Pad the sentences
1596	Check null data
1597	checking missing data
1598	Check the dataset
1599	checking missing data
1600	Create color map ranging between two colors
1601	checking missing data
1602	Moving average is so simple
1603	Find Null data
1604	Extract columns with null data
1605	Predict null data based on statistical method
1606	For ordinal group
1607	Onehot encoding for categorical data
1608	Parameter optimization is needed
1609	Convert splited data into XGBoost format
1610	Target , prediction process
1611	label encode the categorical variables and convert the numerical variables to float
1612	Split the train dataset into development and valid based on time
1613	Split the train dataset into development and valid based on time
1614	Split the train dataset into development and valid based on time
1615	show mask class example
1616	Computes gradient of the Lovasz extension w.r.t sorted errors
1617	remove model activation layer and use losvasz loss
1618	average the predictions from different folds
1619	Null data check
1620	checking missing data
1621	It seems Goblins are a little similar to Ghouls
1622	Print the feature ranking
1623	Logistic Regression seems to be a good classification algorithm for this dataset
1624	You only have two areas to work on
1625	Add active column
1626	Predict by Specify Province
1627	Predict by Specify Country
1628	Predict all country greater than
1629	All Country Confirmed Greater than
1630	Predict all province greater than
1631	check the old format
1632	for some countries , data is spread over several Provinces
1633	Age distribution of male and female patients
1634	Difference varialbes were created to describe the difference beween maximum and minimum value
1635	Here is a base model without parameter tuning .
1636	dummy variable for hour color bands in test
1637	CUMMULATIVE COUNTS FEATURES
1638	visualize distribution of attributions by minute
1639	check for hourly patterns
1640	Loading in the train data
1641	Explore ip counts
1642	temporary table to see ips with their associated count frequencies
1643	Conversions by Device
1644	check for hourly patterns
1645	learning rates for corse training
1646	Change the Original CNN extra data MLP
1647	Loop over all Folds
1648	Prepare validation data
1649	Preparing the data
1650	Use machine learning model
1651	create one more submission
1652	import Dataset to play with it
1653	distribution of targets
1654	check covariance among importance variables
1655	Draw the heatmap using seaborn
1656	written by MJ Bahmani
1657	This notebook will deal with positive , negative and neutral samples independently
1658	restore original text
1659	For neutral samples , use original texts as they are
1660	Write a problem file
1661	Plot the obtained tour
1662	same plane as the original data , cut at the Z axis
1663	kick off the animation
1664	Import libraries and data , reduce memory usage
1665	fill in mean for floats
1666	Specify parameters for stacked model and begin training
1667	Write predictions to csv
1668	At the scale of stores
1669	gather input and output parts of the pattern
1670	Disable fastai randomness
1671	Load train and test dataframes and add length columns for Description and Name
1672	Initialize patient entry into parsed
1673	Add box if opacity is present
1674	Add boxes with random color if present
1675	What Does a Normal Image Look Like
1676	What are Lung Opacities
1677	Opacities That Are Not Related to Pneumonia
1678	convert text into datetime
1679	get some sessions information
1680	the time spent in the app so far
1681	the accurace is the all time wins divided by the all time attempts
1682	An optimizer for rounding thresholds
1683	left nearest neighbor
1684	If you like the content of this notebook , please consider upvoting it
1685	Usual numpy , panda , matplotlib and python libraries imports
1686	Split horizontally an image
1687	Make sure everybody have the same shape
1688	Make sure everybody have the same shape
1689	Sort pictures by increasing color id
1690	Sort images by how many non zero pixels are contained
1691	Composition of functions
1692	Lift the function
1693	Give a nice name to the lifted function
1694	Show each image contained in a list
1695	Load my favorite task
1696	The evaluation method
1697	Break if there is no data
1698	Evaluate the program on the input
1699	For each sample
1700	For each fitness function
1701	The pool contain a mix of new single instructions programs
1702	where the key of each program is its fitness score
1703	Compare the new candidate to the existing best candidates
1704	Remove previous best candidate and add the new one
1705	For each best candidate , we look if we have an answer
1706	Give some informations by selecting a random candidate
1707	Solve the task
1708	Importing standard libraries
1709	Importing sklearn libraries
1710	Keras Libraries for Neural Networks
1711	Read data from the CSV file
1712	Since the labels are textual , so we encode them categorically
1713	We used softmax layer to predict a uniform probabilistic distribution of outcomes
1714	cross validation and metrics
1715	Ensure determinism in the results
1716	FUNCTIONS TAKEN FROM
1717	LOAD PROCESSED TRAINING DATA FROM DISK
1718	Tokenize the sentences
1719	shuffling the data
1720	SAVE DATASET TO DISK
1721	LOAD DATASET FROM DISK
1722	The mean of the two is used as the final embedding matrix
1723	missing entries in the embedding are set using np.random.normal
1724	text version of squash , slight different from original one
1725	The method for training is borrowed from
1726	for numerical stability in the loss
1727	Shuffling happens when splitting for kfolds
1728	This enables operations which are only applied during training like dropout
1729	Add train leak
1730	Add leak to test
1731	Function which creates final video from list of images
1732	Samples which have unique values are real the others are fake
1733	Loading libraries and data
1734	the same for test
1735	You can choose many palettes , which makes the graphs visually nice
1736	select some columns
1737	The competition metric relies only on the order of recods ignoring IDs
1738	Lib and Load data
1739	Explore distribution of single variable
1740	We can see above the counts of higher damageDealt smoothly decrease
1741	HANDLE MISSING VALUES
1742	SCALE target variable
1743	EXTRACT DEVELOPTMENT TEST
1744	FITTING THE MODEL
1745	Getting Prime Cities
1746	A lot of the continuous days variables have integers as missing value indicators
1747	NOTE Even tough it is automatic , we can incorporate some manual features
1748	Create an entity from the bureau balance dataframe
1749	Create an entity from the installments dataframe
1750	Create an entity from the previous applications dataframe
1751	Create an entity from the credit card balance dataframe
1752	Create an entity from the POS Cash balance dataframe
1753	Relationship between applications and credits bureau
1754	Relationship between applications and credits bureau
1755	Relationship between applications and credits bureau
1756	Relationship between applications and previous applications
1757	Relationship between applications and credit card balance
1758	Relationship between applications and POS cash balance
1759	Feature primitives Basically which functions are we going to use to create features
1760	Label encoding Making it machine readable
1761	Label encode categoricals
1762	NaN imputation will be skipped in this tutorial
1763	Let us split the variables one more time
1764	Separate into train and test
1765	That is the size of one test example that we ought to predict
1766	cross validation and metrics
1767	Tokenize the sentences , as in introductory example
1768	shuffling the data
1769	Save some memory
1770	missing entries in the embedding are set using np.random.normal
1771	text version of squash , slight different from original one
1772	always call this before training for deterministic results
1773	for numerical stability in the loss
1774	Shuffling happens when splitting for kfolds
1775	This enables operations which are only applied during training like dropout
1776	What should good EDA be capable of
1777	plot the heatmap
1778	Reading in the data , as usual
1779	Generate the Mask for EAP
1780	The wordcloud of the raven for Edgar Allen Poe
1781	Applying it on text
1782	Calling our overwritten Count vectorizer
1783	Worldcloud for the first topic
1784	Compute the STA and the LTA
1785	Avoid division by zero by setting zero values to tiny float
1786	Read and Explore
1787	Fetch one signal from xs
1788	An inner plot to show the peak frequency
1789	Forceasting with decompasable model
1790	For marchine Learning Approach
1791	Feature engineering with the date
1792	Draw a heatmap with the numeric values in each cell
1793	Draw a heatmap with the numeric values in each cell
1794	Modelisation with all product
1795	Model with all data
1796	Show Rolling mean , Rolling Std and Test for the stationnarity
1797	Plot rolling statistics
1798	shift train predictions for plotting
1799	shift test predictions for plotting
1800	plot baseline and predictions
1801	k is camera instrinsic matrix
1802	image coordinate to world coordinate
1803	call this function before chage the dtype
1804	Plot ROC curve
1805	Print out the memory usage
1806	Load in train and test
1807	Load in other files
1808	number of transactions
1809	Replace infs and imputing missing values by mean
1810	RF for feature selection
1811	Print confusion matrix and plot ROC curve
1812	Redefine the featuresets for Autoencoder
1813	Evaluate the Model
1814	Copy predictions to submission file
1815	Thanks to Nanashi
1816	Load CSV files
1817	We can safely store the two types into separate dataframes
1818	update market dataframe to only contain the specific rows with matching indecies
1819	get index column
1820	check if the columns are in the index
